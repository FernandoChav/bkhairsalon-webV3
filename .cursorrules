# BK Hair Salon Web - Reglas de Cursor

## üéØ Objetivos del Proyecto

- **Calidad sobre velocidad**: Priorizar c√≥digo mantenible y robusto
- **User Experience First**: Todas las decisiones deben mejorar la experiencia del usuario
- **Type Safety**: Aprovechar TypeScript al m√°ximo para prevenir errores en tiempo de compilaci√≥n
- **Performance**: Optimizar para Web Vitals y experiencia m√≥vil
- **Accesibilidad**: Cumplir con est√°ndares WCAG 2.1 AA m√≠nimo
- **Testing**: C√≥digo cr√≠tico debe estar cubierto con tests

## üìê Arquitectura y Capas

### Estructura de Capas (Dependency Flow)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  UI Layer (views/, components/)     ‚îÇ ‚Üê Solo renderiza y maneja eventos
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Logic Layer (hooks/)               ‚îÇ ‚Üê L√≥gica de negocio y estado
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Data Layer (clients/, atoms/)      ‚îÇ ‚Üê Comunicaci√≥n con APIs y estado global
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Domain Layer (models/)             ‚îÇ ‚Üê Tipos, schemas, entidades
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Responsabilidades por Capa

#### 1. **UI Layer** (`views/`, `components/`)

- **Responsabilidad √∫nica**: Renderizar UI y capturar eventos del usuario
- **NO debe**: Contener l√≥gica de negocio, llamadas directas a APIs, validaciones complejas
- **S√ç debe**: Delegar toda la l√≥gica a hooks custom
- **Patr√≥n**: Container/Presenter Pattern
- **CR√çTICO**: Todos los valores computados deben calcularse ANTES del return del JSX
- **CR√çTICO**: NO incluir l√≥gica condicional o transformaciones dentro del JSX
- **CR√çTICO**: Todas las props definidas deben ser utilizadas, no declarar props innecesarias
- **CR√çTICO**: Todo lo que retorna un hook DEBE ser utilizado en el componente
- **CR√çTICO**: Handlers de eventos deben seguir el patr√≥n `handle[EventName]` en camelCase
- **CR√çTICO**: NO usar `useState` en componentes UI - extraer a hooks custom
- **CR√çTICO**: `'use client'` solo en la vista principal (`index.tsx`), NO en componentes internos

```typescript
// ‚úÖ CORRECTO - Computed values antes del JSX
export const RegisterView = () => {
  const { form, handleSubmit, isLoading, isValid } = useRegisterForm();

  // ‚úÖ Todos los valores computados ANTES del return
  const buttonText = isLoading ? 'Creando cuenta...' : 'Crear cuenta';
  const buttonClassName = cn(
    'w-full',
    isValid ? 'bg-primary' : 'bg-muted'
  );
  const shouldShowError = !isValid && form.formState.isDirty;

  return (
    <form onSubmit={handleSubmit}>
      <Button className={buttonClassName}>{buttonText}</Button>
      {shouldShowError && <ErrorMessage />}
    </form>
  );
};

// ‚ùå INCORRECTO - L√≥gica en el JSX
export const RegisterView = () => {
  const { form, handleSubmit, isLoading, isValid } = useRegisterForm();

  return (
    <form onSubmit={handleSubmit}>
      {/* ‚ùå L√≥gica condicional en el JSX */}
      <Button className={isValid ? 'bg-primary' : 'bg-muted'}>
        {isLoading ? 'Creando cuenta...' : 'Crear cuenta'}
      </Button>
    </form>
  );
};

// ‚ùå INCORRECTO - Props no utilizadas
interface ButtonProps {
  onClick: () => void;
  variant?: 'primary' | 'secondary'; // ‚ùå Si no se usa, no declarar
  size?: 'sm' | 'md' | 'lg'; // ‚ùå Si no se usa, no declarar
}

// ‚úÖ CORRECTO - Solo props que se usan
interface ButtonProps {
  onClick: () => void;
}

// ‚ùå INCORRECTO - Retorno de hook no utilizado
const { data, isLoading, error, refetch } = useQuery(); // ‚ùå Si refetch no se usa, no desestructurar

// ‚úÖ CORRECTO - Solo lo que se usa
const { data, isLoading, error } = useQuery();
```

##### Ejemplo de useState Incorrecto

```typescript
// ‚ùå INCORRECTO - useState en componente UI
export const LoginForm = () => {
  const [showPassword, setShowPassword] = useState(false); // ‚ùå useState en UI
  const [isLoading, setIsLoading] = useState(false); // ‚ùå useState en UI

  const handleSubmit = (data) => {
    setIsLoading(true); // ‚ùå L√≥gica en componente
    // ... l√≥gica de submit
  };

  return (
    <form onSubmit={handleSubmit}>
      <Input type={showPassword ? 'text' : 'password'} />
      <Button onClick={() => setShowPassword(!showPassword)}>
        {showPassword ? 'Ocultar' : 'Mostrar'}
      </Button>
    </form>
  );
};

// ‚úÖ CORRECTO - L√≥gica en hook custom
export const LoginForm = () => {
  const { form, showPassword, isLoading, handleSubmit, handlePasswordToggle } = useLoginForm();

  return (
    <form onSubmit={handleSubmit}>
      <Input type={showPassword ? 'text' : 'password'} />
      <Button onClick={handlePasswordToggle}>
        {showPassword ? 'Ocultar' : 'Mostrar'}
      </Button>
    </form>
  );
};
```

##### Ejemplo de 'use client' Correcto

```typescript
// ‚úÖ CORRECTO - 'use client' solo en la vista principal
// src/views/app/login/index.tsx
'use client';

import { FC } from 'react';
import { LoginForm } from './components';
import { useLoginView } from './hooks';

export const LoginView: FC = () => {
  const { form, handleSubmit, isLoading } = useLoginView();

  return (
    <div>
      <LoginForm 
        form={form}
        handleSubmit={handleSubmit}
        isLoading={isLoading}
      />
    </div>
  );
};

// ‚úÖ CORRECTO - Componente interno SIN 'use client'
// src/views/app/login/components/login-form.tsx
import { FC } from 'react';

interface LoginFormProps {
  form: UseFormReturn<LoginForm>;
  handleSubmit: () => void;
  isLoading: boolean;
}

export const LoginForm: FC<LoginFormProps> = ({ form, handleSubmit, isLoading }) => {
  return (
    <form onSubmit={handleSubmit}>
      {/* JSX del formulario */}
    </form>
  );
};

// ‚ùå INCORRECTO - 'use client' repetitivo en componentes internos
// src/views/app/login/components/login-form.tsx
'use client'; // ‚ùå NO debe estar aqu√≠

import { FC } from 'react';

export const LoginForm: FC<LoginFormProps> = ({ form, handleSubmit, isLoading }) => {
  return (
    <form onSubmit={handleSubmit}>
      {/* JSX del formulario */}
    </form>
  );
};
```

##### Convenci√≥n para Handlers

```typescript
// ‚úÖ CORRECTO - Nomenclatura de handlers
const handleSubmit = () => {
  /* ... */
};
const handleClick = () => {
  /* ... */
};
const handlePasswordToggle = () => {
  /* ... */
};
const handleFileUpload = (files: File[]) => {
  /* ... */
};
const handleModalClose = () => {
  /* ... */
};

// ‚ùå INCORRECTO - Nomenclatura inconsistente
const onSubmit = () => {
  /* ... */
}; // ‚ùå Usar handle, no on
const submitHandler = () => {
  /* ... */
}; // ‚ùå Usar handle al inicio
const clickEvent = () => {
  /* ... */
}; // ‚ùå No usar "event"
```

#### 2. **Logic Layer** (`hooks/`)

##### `hooks/api/` - Hooks de datos (React Query)

- **Responsabilidad**: Gesti√≥n de estado del servidor (cache, refetch, mutations)
- **Convenci√≥n de nombres**:
  - Queries: `use[Entity][Action]Query` (ej: `useUserProfileQuery`)
  - Mutations: `use[Action][Entity]Mutation` (ej: `useEditUserMutation`)
- **CR√çTICO**: Solo retornar lo que realmente se usa en los consumidores
- **CR√çTICO**: Si un valor del retorno no se usa en ning√∫n lugar, no exponerlo

```typescript
// ‚úÖ CORRECTO - Solo retorna lo necesario
export const useUserProfileQuery = () => {
  const { data, isLoading, error } = useQuery({
    queryKey: ['user', 'profile'],
    queryFn: fetchProfile,
  });

  // Solo retornar lo que se usa
  return { data, isLoading, error };
};

// ‚ùå INCORRECTO - Retorna cosas no utilizadas
export const useUserProfileQuery = () => {
  const queryResult = useQuery({ /* ... */ });

  // ‚ùå Retornar todo el objeto cuando solo se usan 3 propiedades
  return queryResult;
};
```

##### `hooks/common/` - Hooks de UI

- **Responsabilidad**: L√≥gica reutilizable de UI (validaci√≥n, estado local, side effects)
- **Convenci√≥n de nombres**: `use[Feature]` (ej: `useFileUpload`, `useProgress`)
- **CR√çTICO**: Retornar objeto con API clara y m√≠nima
- **CR√çTICO**: Todo lo que se retorna debe tener un caso de uso real
- **CR√çTICO**: Orden de exportaci√≥n: primero valores, luego handlers

##### Hooks de formulario (views/\_/hooks/)

- **Responsabilidad**: Orquestar l√≥gica de formularios espec√≠ficos
- **Debe combinar**: react-hook-form, validaci√≥n Zod, mutations, transformaciones
- **Patr√≥n**: Single Source of Truth para el estado del formulario
- **CR√çTICO**: Solo retornar valores que el componente consumidor realmente necesita
- **CR√çTICO**: Relaci√≥n directa con componente-vista: `use-[component-name]-form` debe corresponder a `[ComponentName]`
- **CR√çTICO**: Un hook = un componente principal, no m√∫ltiples componentes
- **CR√çTICO**: Orden de exportaci√≥n: primero valores, luego handlers

```typescript
// ‚úÖ Hook de formulario bien estructurado
export const useRegisterForm = () => {
  const form = useForm<RegisterRequest>({ /* ... */ });
  const { mutate, isPending } = useRegisterMutation();

  const handleSubmit = (data) => {
    const transformed = transformData(data);
    mutate(transformed, { onSuccess, onError });
  };

  // Solo retornar lo que el componente usa
  // ‚úÖ ORDEN CORRECTO: primero valores, luego handlers
  return {
    // Valores
    form,
    isLoading: isPending,
    isValid: form.formState.isValid,
    // Handlers
    handleSubmit,
  };
};

// ‚ùå INCORRECTO - Retorna demasiado
export const useRegisterForm = () => {
  const form = useForm<RegisterRequest>({ /* ... */ });
  const mutation = useRegisterMutation();

  // ‚ùå Exponer mutation completo cuando solo se necesita isPending
  return { form, mutation };
};
```

##### Orden de Exportaci√≥n en Hooks

```typescript
// ‚úÖ CORRECTO - Orden: primero valores, luego handlers
export const useEditUserForm = () => {
  const form = useForm<EditUserForm>({ /* ... */ });
  const { data: profile, isLoading } = useUserProfileQuery();
  
  const handleSubmit = (data: EditUserForm) => {
    /* ... */
  };
  
  const handleReset = () => {
    /* ... */
  };

  return {
    // Valores (estado, datos, computed values)
    form,
    profile,
    isLoading,
    canSubmit: form.formState.isValid,
    hasChanges: /* computed value */,
    
    // Handlers (funciones de manejo de eventos)
    handleSubmit,
    handleReset,
  };
};

// ‚ùå INCORRECTO - Orden mezclado
export const useEditUserForm = () => {
  return {
    handleSubmit,     // ‚ùå Handler primero
    form,            // ‚ùå Valor despu√©s
    handleReset,     // ‚ùå Handler mezclado
    isLoading,       // ‚ùå Valor mezclado
  };
};
```

##### Relaci√≥n Hook-Componente

- **CR√çTICO**: Los hooks en `views/*/hooks/` deben tener relaci√≥n directa 1:1 con su componente principal
- **Convenci√≥n**: `use-[component-name]-form` ‚Üí `[ComponentName]`
- **Ejemplos**:
  - `use-edit-user-form.ts` ‚Üí `EditUserForm` (componente principal)
  - `use-login-form.ts` ‚Üí `LoginView` (vista principal)
  - `use-register-form.ts` ‚Üí `RegisterView` (vista principal)

```typescript
// ‚úÖ CORRECTO - Relaci√≥n directa
// use-edit-user-form.ts
export const useEditUserForm = () => {
  // L√≥gica espec√≠fica para EditUserForm
  return { form, handleSubmit, isLoading };
};

// EditUserForm.tsx
export const EditUserForm = () => {
  const { form, handleSubmit, isLoading } = useEditUserForm();
  // Solo usa este hook
};

// ‚ùå INCORRECTO - Hook sobrecargado para m√∫ltiples componentes
// use-edit-user-form.ts
export const useEditUserForm = () => {
  // L√≥gica para EditUserForm
  // L√≥gica para ConfirmPasswordModal
  // L√≥gica para otros componentes
  return { 
    form, 
    modal, 
    passwordToggle, 
    // ... demasiadas responsabilidades
  };
};
```

#### 3. **Data Layer** (`clients/`, `atoms/`)

##### `clients/` - HTTP Clients (Axios)

- **Responsabilidad**: Comunicaci√≥n con APIs externas
- **Patr√≥n**: Repository Pattern
- **Convenci√≥n**: Una clase por recurso/entidad
- **Debe**: Tipar requests y responses con interfaces de `models/`

```typescript
// ‚úÖ Cliente bien estructurado
class UserClient {
  async getProfile(): Promise<ApiResponse<ProfileDto>> {
    const response =
      await baseClient.get<ApiResponse<ProfileDto>>('/user/profile');
    return response.data;
  }
}
```

##### `atoms/` - Estado Global (Jotai)

- **Cu√°ndo usar**: Estado compartido entre componentes no relacionados
- **Cu√°ndo NO usar**: Estado local de componentes, estado de formularios
- **Convenci√≥n**: Atoms primitivos + atoms derivados para acciones

#### 4. **Domain Layer** (`models/`)

##### `models/schemas/` - Validaci√≥n (Zod)

- **Responsabilidad**: Definir schemas de validaci√≥n
- **Convenci√≥n**: `[entity]Schema` (ej: `registerSchema`, `loginSchema`)
- **Debe**: Exportar tanto el schema como el tipo TypeScript inferido

##### `models/requests/` - DTOs de Request

- **Responsabilidad**: Tipos para datos que se env√≠an al backend

##### `models/responses/` - DTOs de Response

- **Responsabilidad**: Tipos para datos que se reciben del backend

##### `models/entities/` - Entidades de Dominio

- **Responsabilidad**: Modelos de dominio del negocio

## üé® Patrones de Dise√±o

### 1. Repository Pattern (Clients)

```typescript
// clients/user-client.ts
class UserClient {
  async getAll(): Promise<User[]> {
    /* ... */
  }
  async getById(id: string): Promise<User> {
    /* ... */
  }
  async create(data: CreateUserDto): Promise<User> {
    /* ... */
  }
  async update(id: string, data: UpdateUserDto): Promise<User> {
    /* ... */
  }
  async delete(id: string): Promise<void> {
    /* ... */
  }
}
```

### 2. Custom Hooks Pattern

- Encapsular l√≥gica compleja en hooks reutilizables
- Un hook = una responsabilidad
- Hooks pueden componer otros hooks
- **CR√çTICO**: Solo retornar lo que se consume
- **CR√çTICO**: `useState` solo en hooks, nunca en componentes UI
- **Patr√≥n**: Hook = l√≥gica + estado, Componente = renderizado

### 3. Compound Components Pattern (shadcn/ui)

```typescript
<Card>
<CardHeader>
<CardTitle>Title</CardTitle>
</CardHeader>
<CardContent>Content</CardContent>
</Card>
```

### 4. Render Props / Children as Function (cuando sea necesario)

### 5. Error Boundary Pattern

- Implementar error boundaries para secciones cr√≠ticas
- Mostrar UI de fallback amigable

## üìã Principios y Mejores Pr√°cticas

### Principios SOLID

#### Single Responsibility Principle (SRP)

- Cada m√≥dulo/funci√≥n/componente debe tener **una sola raz√≥n para cambiar**
- Ejemplo: Separar l√≥gica de formulario en hook custom

#### Open/Closed Principle (OCP)

- Componentes abiertos a extensi√≥n, cerrados a modificaci√≥n
- Usar composici√≥n y props para extender funcionalidad

#### Liskov Substitution Principle (LSP)

- Los subcomponentes deben poder sustituir a sus componentes base

#### Interface Segregation Principle (ISP)

- Preferir interfaces espec√≠ficas sobre interfaces generales
- No forzar a componentes a depender de props que no usan
- **CR√çTICO**: No declarar props que no se utilizan

#### Dependency Inversion Principle (DIP)

- Depender de abstracciones (interfaces/types), no de implementaciones concretas

### DRY (Don't Repeat Yourself)

- Si algo se repite 3+ veces ‚Üí extraer a funci√≥n/componente/hook
- Reutilizar componentes de shadcn/ui en lugar de crear propios

### KISS (Keep It Simple, Stupid)

- Preferir soluciones simples sobre complejas
- No sobre-abstraer prematuramente

### YAGNI (You Aren't Gonna Need It)

- No agregar funcionalidad "por si acaso"
- Implementar solo lo que se necesita ahora
- **CR√çTICO**: No retornar valores de hooks que no se usan
- **CR√çTICO**: No declarar props que no tienen uso

### Separation of Concerns

- L√≥gica de negocio ‚â† L√≥gica de presentaci√≥n
- Efectos secundarios ‚â† Renderizado
- **CR√çTICO**: Computed values ‚â† JSX rendering

### Composition over Inheritance

- React favorece composici√≥n
- Usar props.children, render props, hooks custom

## üîí TypeScript - Reglas Estrictas

### Type Safety

```typescript
// ‚úÖ CORRECTO
interface User {
  id: string;
  name: string;
}

const user: User = { id: '1', name: 'John' };

// ‚ùå INCORRECTO
const user: any = { id: '1', name: 'John' }; // No usar 'any'
```

### Type Guards

```typescript
// ‚úÖ Usar type guards para narrowing
if (error instanceof AxiosError) {
  // TypeScript sabe que error es AxiosError aqu√≠
}
```

### Utility Types

- Usar `Partial<T>`, `Pick<T>`, `Omit<T>`, `Required<T>` cuando sea apropiado
- Preferir tipos expl√≠citos sobre inferencia en interfaces p√∫blicas

### Evitar Type Assertions

```typescript
// ‚ùå EVITAR
const user = data as User;

// ‚úÖ PREFERIR validaci√≥n
const user = UserSchema.parse(data);
```

## üéØ Convenciones de C√≥digo

### Convenciones de Nomenclatura

#### Componentes

- **PascalCase**: `UserProfile`, `LoginForm`
- **Descriptivos**: Lo que hace, no c√≥mo lo hace
- **Sufijos comunes**: `*View`, `*Form`, `*Modal`, `*Card`, `*List`

#### Hooks

- **Prefijo `use`**: `useUserProfile`, `useAuth`
- **camelCase**: `useFileUpload`, `useProgress`

#### Funciones/Variables

- **camelCase**: `getUserById`, `isLoading`
- **Descriptivos**: Nombres que revelen intenci√≥n

#### Variables Booleanas

- **CR√çTICO**: Siempre usar prefijo `is` para variables booleanas
- **Patr√≥n**: `is[State]` o `is[Condition]`
- **Ejemplos**: `isOpen`, `isLoading`, `isValid`, `isSubmitting`, `isVisible`
- **CR√çTICO**: Props booleanas tambi√©n deben usar prefijo `is`
- **Patr√≥n para props**: `is[State]` o `is[Condition]`

```typescript
// ‚úÖ CORRECTO - Variables booleanas
const isOpen = useState(false);
const isLoading = false;
const isValid = form.formState.isValid;
const isSubmitting = mutation.isPending;

// ‚úÖ CORRECTO - Props booleanas
<ConfirmPasswordModal
  isOpen={modal.show}           // ‚úÖ Prefijo is
  isLoading={isSubmitting}      // ‚úÖ Prefijo is
  isValid={form.formState.isValid}  // ‚úÖ Prefijo is
  handleClose={modal.handleClose}
  handleConfirm={modal.handleConfirm}
/>

// ‚ùå INCORRECTO - Variables booleanas sin prefijo
const open = useState(false);     // ‚ùå Sin prefijo is
const loading = false;            // ‚ùå Sin prefijo is
const valid = form.formState.isValid;  // ‚ùå Sin prefijo is

// ‚ùå INCORRECTO - Props booleanas sin prefijo
<ConfirmPasswordModal
  open={modal.show}              // ‚ùå Sin prefijo is
  loading={isSubmitting}         // ‚ùå Sin prefijo is
  valid={form.formState.isValid} // ‚ùå Sin prefijo is
  handleClose={modal.handleClose}
/>
```

#### Handlers de Eventos

- **CR√çTICO**: Siempre usar prefijo `handle` en camelCase
- **Patr√≥n**: `handle[EventName]` o `handle[Action]`
- **Ejemplos**: `handleSubmit`, `handleClick`, `handlePasswordToggle`, `handleModalClose`
- **CR√çTICO**: Props que son funciones tambi√©n deben usar prefijo `handle`
- **Patr√≥n para props**: `handle[EventName]` o `handle[Action]`

```typescript
// ‚úÖ CORRECTO - Handlers internos
const handleSubmit = (data: FormData) => {
  /* ... */
};
const handleFileSelect = (files: File[]) => {
  /* ... */
};
const handlePasswordVisibilityToggle = () => {
  /* ... */
};

// ‚úÖ CORRECTO - Props que son funciones
<EditUserForm
  form={form}
  canSubmit={canSubmit}
  handleFormSubmit={modal.handleSubmit}  // ‚úÖ Prefijo handle
  handlePasswordToggle={modal.handlePasswordToggle}  // ‚úÖ Prefijo handle
/>

// ‚ùå INCORRECTO - Handlers internos
const onSubmit = (data: FormData) => {
  /* ... */
};
const submitHandler = (data: FormData) => {
  /* ... */
};
const clickEvent = () => {
  /* ... */
};

// ‚ùå INCORRECTO - Props que son funciones
<EditUserForm
  form={form}
  canSubmit={canSubmit}
  onFormSubmit={modal.handleSubmit}  // ‚ùå Prefijo on
  onPasswordToggle={modal.handlePasswordToggle}  // ‚ùå Prefijo on
/>
```

#### Constantes

- **UPPER_SNAKE_CASE**: `MAX_FILE_SIZE`, `API_BASE_URL`
- Para valores verdaderamente constantes

#### Tipos/Interfaces

- **PascalCase**: `UserProfile`, `ApiResponse<T>`
- **Sufijos**: `*Props`, `*State`, `*Response`, `*Request`, `*Dto`

#### Orden de Interfaces y Props

- **CR√çTICO**: En interfaces, ordenar props: primero valores, luego handlers
- **CR√çTICO**: En desestructuraci√≥n de props, mantener el mismo orden que la interface
- **CR√çTICO**: Al pasar props a componentes, mantener el mismo orden: primero valores, luego handlers

```typescript
// ‚úÖ CORRECTO - Interface con orden correcto
interface EditUserFormProps {
  // Valores (estado, datos, computed values)
  form: UseFormReturn<EditUserForm>;
  canSubmit: boolean;
  isSubmitting: boolean;
  isLoading: boolean;
  
  // Handlers (funciones de manejo de eventos)
  handleFormSubmit: () => void;
  handleReset: () => void;
}

// ‚úÖ CORRECTO - Desestructuraci√≥n con mismo orden
export const EditUserForm: FC<EditUserFormProps> = ({
  // Valores primero
  form,
  canSubmit,
  isSubmitting,
  isLoading,
  // Handlers despu√©s
  handleFormSubmit,
  handleReset,
}) => {
  // ... componente
};

// ‚úÖ CORRECTO - Props pasadas con mismo orden
<EditUserForm
  // Valores primero
  form={form}
  canSubmit={canSubmit}
  isSubmitting={isSubmitting}
  isLoading={isLoading}
  // Handlers despu√©s
  handleFormSubmit={handleFormSubmit}
  handleReset={handleReset}
/>

// ‚ùå INCORRECTO - Orden mezclado en interface
interface EditUserFormProps {
  handleFormSubmit: () => void;  // ‚ùå Handler primero
  form: UseFormReturn<EditUserForm>;  // ‚ùå Valor despu√©s
  handleReset: () => void;  // ‚ùå Handler mezclado
  canSubmit: boolean;  // ‚ùå Valor mezclado
}

// ‚ùå INCORRECTO - Orden mezclado en desestructuraci√≥n
export const EditUserForm: FC<EditUserFormProps> = ({
  handleFormSubmit,  // ‚ùå Handler primero
  form,  // ‚ùå Valor despu√©s
  canSubmit,  // ‚ùå Valor mezclado
  handleReset,  // ‚ùå Handler mezclado
}) => {
  // ... componente
};

// ‚ùå INCORRECTO - Orden mezclado al pasar props
<EditUserForm
  handleFormSubmit={handleFormSubmit}  // ‚ùå Handler primero
  form={form}  // ‚ùå Valor despu√©s
  canSubmit={canSubmit}  // ‚ùå Valor mezclado
  handleReset={handleReset}  // ‚ùå Handler mezclado
/>
```

### Estructura de Archivos

```
feature/
‚îú‚îÄ‚îÄ index.tsx # Exporta el componente principal
‚îú‚îÄ‚îÄ components/ # Componentes internos
‚îÇ ‚îú‚îÄ‚îÄ index.ts # Barrel export
‚îÇ ‚îú‚îÄ‚îÄ FeatureForm.tsx
‚îÇ ‚îî‚îÄ‚îÄ FeatureCard.tsx
‚îî‚îÄ‚îÄ hooks/ # Hooks espec√≠ficos
‚îú‚îÄ‚îÄ index.ts
‚îî‚îÄ‚îÄ useFeatureForm.ts
```

### Orden de Imports (Prettier plugin)

1. React
2. Next.js
3. Third-party libraries
4. Internal imports (@/)
5. Relative imports (./,../)

## üß™ Gu√≠as de Testing

### Qu√© testear

- ‚úÖ L√≥gica de negocio compleja (hooks custom)
- ‚úÖ Componentes cr√≠ticos de UI
- ‚úÖ Utilidades y helpers
- ‚úÖ Validaciones (schemas Zod)
- ‚ùå Componentes triviales de UI
- ‚ùå C√≥digo generado autom√°ticamente

### Convenci√≥n de Nomenclatura

```typescript
// archivo: use-register-form.test.ts
describe('useRegisterForm', () => {
  describe('Inicializaci√≥n', () => {
    it('debe inicializar con valores por defecto', () => {});
  });

  describe('Validaci√≥n', () => {
    it('debe validar email correctamente', () => {});
  });

  describe('Submit', () => {
    it('debe llamar a la API con datos transformados', () => {});
  });
});
```

### Patr√≥n AAA (Arrange, Act, Assert)

```typescript
it('debe registrar usuario exitosamente', async () => {
  // Arrange
  const mockData = {
    /* ... */
  };

  // Act
  const result = await register(mockData);

  // Assert
  expect(result).toEqual(expectedResult);
});
```

## üé® Gu√≠as de UI/UX

### Dise√±o Responsive

- **Mobile-first**: Dise√±ar primero para m√≥vil
- **Breakpoints Tailwind**:
  - `sm: 640px`
  - `md: 768px`
  - `lg: 1024px`
  - `xl: 1280px`
  - `2xl: 1536px`

### Accesibilidad

- Usar elementos sem√°nticos HTML
- Agregar `aria-labels` cuando sea necesario
- Keyboard navigation funcional
- Focus visible
- Contrast ratios WCAG AA

### Estados de Carga

- Siempre mostrar feedback durante operaciones async
- Usar `<LoadingSpinner>` o `<Skeleton>` components
- Deshabilitar botones durante loading

### Manejo de Errores en UX

- Mensajes de error claros y accionables
- Validaci√≥n en tiempo real (onTouched)
- Mostrar errores cerca del campo relevante

### Animaciones

- Usar `transition-*` utilities de Tailwind
- Mantener animaciones sutiles y r√°pidas (<300ms)
- Respetar `prefers-reduced-motion`

## üîê Seguridad

### Autenticaci√≥n

- Tokens en cookies HTTP-only (NextAuth)
- Refresh tokens autom√°tico (implementado en `base-client.ts`)
- Validar sesi√≥n en middleware

### Validaci√≥n

- **Backend + Frontend**: Nunca confiar solo en validaci√≥n client-side
- Usar Zod para schemas consistentes

### Prevenci√≥n de XSS

- React escapa autom√°ticamente
- Cuidado con `dangerouslySetInnerHTML`

### Protecci√≥n CSRF

- NextAuth maneja CSRF tokens

## üìä Performance

### Code Splitting

- Next.js lo hace autom√°ticamente
- Usar dynamic imports para componentes pesados

### Optimizaci√≥n de Im√°genes

- Usar `<Image>` de Next.js
- Lazy loading por defecto

### Memoizaci√≥n

- `useMemo` para c√°lculos costosos
- `useCallback` para funciones pasadas a componentes hijo
- `React.memo` para componentes puros

### Tama√±o del Bundle

- Revisar imports: importar solo lo necesario

```typescript
// ‚úÖ CORRECTO
import { Button } from '@/components/shadcn';
// ‚ùå INCORRECTO
import * as Components from '@/components/shadcn';
```

## üö® Manejo de Errores

### Patr√≥n de Manejo de Errores

#### En Clients

```typescript
// El cliente solo lanza excepciones, no las maneja
async create(data: CreateDto): Promise<Response> {
  const response = await baseClient.post('/endpoint', data);
  return response.data; // Dejar que errores se propaguen
}
```

#### En Hooks (React Query)

```typescript
const { mutate } = useMutation({
  mutationFn: client.create,
  onError: (error: AxiosError<ApiResponse>) => {
    if (isValidationError(error)) {
      // Mostrar errores de validaci√≥n
      const messages = extractValidationMessages(error);
      messages.forEach(toast.error);
    } else {
      // Error gen√©rico
      toast.error(error.response?.data?.message || 'Error desconocido');
    }
  },
});
```

#### En UI

- Mostrar loading states
- Mostrar errores con `toast` (Sonner)
- Proveer fallbacks UI

## üîÑ Estrategia de Manejo de Estado

### Estado Local (useState)

- **Cu√°ndo**: Estado que solo afecta a un componente
- **Ejemplo**: Mostrar/ocultar contrase√±a, tabs activos
- **CR√çTICO**: NO usar `useState` en componentes UI - extraer a hooks custom
- **Patr√≥n**: `useState` solo en hooks, no en componentes
- **Cu√°ndo S√ç usar**: En hooks custom para encapsular l√≥gica de estado

### Estado de Formulario (react-hook-form)

- **Cu√°ndo**: Cualquier formulario
- **Por qu√©**: Validaci√≥n, performance, DX

### Estado del Servidor (React Query)

- **Cu√°ndo**: Datos que vienen del backend
- **Por qu√©**: Cache, sincronizaci√≥n, revalidaci√≥n autom√°tica

### Estado Global (Jotai)

- **Cu√°ndo**: Estado compartido entre componentes no relacionados
- **Ejemplo**: Tema, progreso de navegaci√≥n, preferencias de usuario

### Estado en URL (Next.js)

- **Cu√°ndo**: Estado que debe persistir en la URL
- **Ejemplo**: Filtros, b√∫squeda, paginaci√≥n

## üìù Documentaci√≥n

### JSDoc

- Documentar funciones/hooks p√∫blicos complejos
- Incluir ejemplos de uso cuando sea √∫til

### README de Componentes

- Componentes complejos deben tener documentaci√≥n
- Incluir props disponibles y ejemplos

### Comentarios en C√≥digo

- Explicar **por qu√©**, no **qu√©**
- Comentar decisiones de dise√±o no obvias
- TODO comments con nombre y fecha

```typescript
// ‚úÖ BUEN comentario
// Usamos setTimeout en lugar de useEffect para evitar re-renders
// Ver: https://github.com/facebook/react/issues/14920

// ‚ùå MAL comentario
// Incrementa el contador
count++;
```

## üöÄ Deployment & CI/CD

### Pre-commit Hooks (Husky + lint-staged)

- ESLint fix
- Prettier format
- Type checking (opcional)

### Verificaciones de Build

- `yarn build` debe pasar
- `yarn type-check` debe pasar
- `yarn lint` debe pasar
- `yarn test:run` debe pasar (si aplica)

## üìö Recursos de Aprendizaje

- [Next.js Docs](https://nextjs.org/docs)
- [React Query Docs](https://tanstack.com/query/latest)
- [shadcn/ui](https://ui.shadcn.com/)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [Refactoring UI](https://www.refactoringui.com/)

## ‚ö†Ô∏è Errores Comunes a Evitar

1. **No usar `any`** - Rompe type safety
2. **No hacer fetch directo en componentes** - Usar hooks de React Query
3. **No poner l√≥gica en componentes UI** - Extraer a hooks
4. **No usar useState en componentes UI** - Extraer a hooks custom
5. **No olvidar loading/error states** - Siempre manejarlos
6. **No usar √≠ndices como keys** - Usar IDs √∫nicos y estables
7. **No abusar de useEffect** - Considerar alternativas
8. **No mezclar estilos inline con Tailwind** - Ser consistente
9. **No hardcodear strings repetidos** - Usar constantes
10. **No ignorar warnings del linter** - Entenderlos y resolverlos
11. **No sobre-optimizar prematuramente** - Medir primero
12. **No poner l√≥gica en el JSX** - Calcular computed values antes del return
13. **No declarar props no utilizadas** - Solo declarar lo que se usa
14. **No retornar valores no utilizados de hooks** - Solo retornar lo necesario
15. **No usar nomenclatura inconsistente en handlers** - Siempre `handle[EventName]`
16. **No usar prefijo `on` en props de funciones** - Usar `handle[EventName]` para props que son funciones
17. **No mezclar orden en exportaci√≥n de hooks** - Primero valores, luego handlers
18. **No usar `npm`** - Este proyecto usa `yarn`
19. **No crear hooks sobrecargados** - Un hook = un componente principal, relaci√≥n 1:1
20. **No usar variables booleanas sin prefijo `is`** - Siempre usar `is[State]` para claridad
21. **No repetir `'use client'` en componentes internos** - Solo en la vista principal (`index.tsx`)
22. **No mezclar orden en interfaces y props** - Primero valores, luego handlers

## üõ†Ô∏è Herramientas y Comandos

### Gesti√≥n de Paquetes

- **Package Manager**: Yarn (NO usar npm)
- Instalar dependencias: `yarn install`
- Agregar dependencia: `yarn add [package]`
- Agregar dev dependency: `yarn add -D [package]`
- Remover dependencia: `yarn remove [package]`

### Comandos de Desarrollo

```bash
# Desarrollo
yarn dev

# Build
yarn build

# Linting
yarn lint
yarn lint:fix

# Type checking
yarn type-check

# Formatting
yarn format
yarn format:check

# Testing
yarn test
yarn test:ui
yarn test:run
yarn test:coverage

# An√°lisis de c√≥digo no utilizado
yarn knip
yarn knip:fix
```

## üìã Checklist Pre-Commit

Antes de hacer commit, verificar:

- [ ] ‚úÖ No hay `any` en el c√≥digo
- [ ] ‚úÖ Todas las props declaradas se utilizan
- [ ] ‚úÖ Todo lo que retorna un hook se utiliza
- [ ] ‚úÖ Computed values est√°n antes del return del JSX
- [ ] ‚úÖ Handlers siguen el patr√≥n `handle[EventName]`
- [ ] ‚úÖ No hay l√≥gica en el JSX
- [ ] ‚úÖ No hay `useState` en componentes UI
- [ ] ‚úÖ Variables booleanas usan prefijo `is`
- [ ] ‚úÖ `'use client'` solo en vistas principales
- [ ] ‚úÖ Interfaces y props ordenadas: primero valores, luego handlers
- [ ] ‚úÖ `yarn lint` pasa sin errores
- [ ] ‚úÖ `yarn type-check` pasa sin errores
- [ ] ‚úÖ Tests relevantes agregados/actualizados
- [ ] ‚úÖ C√≥digo formateado con Prettier

## üéØ Reglas de Oro

1. **Computed values primero, JSX despu√©s**
2. **Solo declarar lo que se usa (props, retornos de hooks)**
3. **Handlers siempre con prefijo `handle` (internos y props)**
4. **Hooks: primero valores, luego handlers**
5. **Un componente = una responsabilidad**
6. **L√≥gica en hooks, no en componentes**
7. **No useState en componentes UI**
8. **Un hook = un componente principal (relaci√≥n 1:1)**
9. **Type safety siempre, `any` nunca**
10. **Usar `yarn`, no `npm`**
11. **Variables booleanas siempre con prefijo `is`**
12. **`'use client'` solo en vistas principales, no en componentes internos**
13. **Interfaces y props: primero valores, luego handlers**
14. **Mobile-first en todo momento**
15. **Accesibilidad no es opcional**
16. **Testear l√≥gica cr√≠tica**

---

**√öltima actualizaci√≥n**: Mantener este documento actualizado conforme el proyecto evoluciona.
